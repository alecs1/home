//#include <QBackingStore>
//#include <QResizeEvent>
//#include <QPainter>
#include <QCoreApplication>
#include <QTimer>
#include <QTime>
#include <QMutex>

//temporary for debug.
#include <QJsonDocument>

#include <cmath>

extern "C" {
#include "engine/board.h" //should probably restrict to the public interface
#include "engine/gnugo.h"
#include "engine/liberty.h"
//void init_gnugo(float memory, unsigned int seed);
//void compute_scores(int use_chinese_rules);
//float gnugo_estimate_score(float *upper, float *lower);
void value_moves(int color, float pure_threat_value, float our_score,
            int use_thrashing_dragon_heuristics);
}

extern "C" {
//int get_sgfmove(SGFProperty *property);
}


#include "GoTable.h"

#include "GameStruct.h"
#include "GameEndDialog.h"
#include "SaveFile.h"
#include "Utils.h"
#include "Logger.h"
//likely temporary
#include "SettingsWidget.h"


//From play_test.c
void GoTable::replay_node(SGFNode *node, int color_to_replay, float *replay_score,
                 float *total_score, int* playedMoves, int* crtColour, SGFTree* outTree)
{
    SGFProperty *sgf_prop;  /* iterate over properties of the node */
    SGFProperty *move_prop = NULL; /* remember if we see a move property */
    int color; /* color of move to be made at this node. */

    int old_move; /* The move played in the file. */
    int new_move; /* The move generated by GNU Go. */

    const int BUFSIZE=128;
    char buf[BUFSIZE];

    /* Handle any AB / AW properties, and note presence
     * of move properties.
     */

    for (sgf_prop = node->props; sgf_prop; sgf_prop = sgf_prop->next) {
        switch (sgf_prop->name) {
        case SGFAB:
            /* add black */
            add_stone(internal_state, get_sgfmove(internal_state, sgf_prop), BLACK);
            break;
        case SGFAW:
            /* add white */
            add_stone(internal_state, get_sgfmove(internal_state, sgf_prop), WHITE);
            break;
        case SGFB:
        case SGFW:
            move_prop = sgf_prop;  /* remember it for later */
            break;
        }
    }

    /* Only generate moves at move nodes. */
    if (!move_prop)
        return;

    old_move = get_sgfmove(internal_state, move_prop);
    color = (move_prop->name == SGFW) ? WHITE : BLACK;

    if (color == color_to_replay || color_to_replay == GRAY) {
        float new_move_value = 0.0;
        float old_move_value = 0.0;

        /* Get a move from the engine for color. */
        int resign;
        new_move = genmove(internal_state, color, NULL, &resign);

        /* Pick up the relevant values from the potential_moves[] array. */
        if (new_move != PASS_MOVE)
            new_move_value = potential_moves[new_move];
        if (old_move != PASS_MOVE)
            old_move_value = potential_moves[old_move];

        /* Now report on how well the computer generated the move. */
        if (new_move != old_move || !quiet) {
            mprintf(internal_state, "Move %d (%C): ", internal_state->movenum + 1, color);

            if (resign) {
                printf("%s - GNU Go resigns", __func__);
            }
            else {
                mprintf(internal_state, "GNU Go plays %1m ", new_move);
                if (new_move != PASS_MOVE)
                    printf("(%.2f) ", new_move_value);
            }

            mprintf(internal_state, "- Game move %1m ", old_move);
            if (new_move != PASS_MOVE && old_move_value > 0.0)
                printf("(%.2f) ", old_move_value);
            printf("\n");

            *replay_score += new_move_value - old_move_value;
            *total_score += new_move_value;
        }

        if (new_move != old_move) {
            if (resign) {
                printf("%s - GNU Go resigns - Game move %s (%.2f)",
                            __func__, location_to_string(internal_state, old_move), old_move_value);
            }
            else {
                printf("%s - GNU Go plays %s (%.2f) - Game move %s (%.2f)",
                            __func__, location_to_string(internal_state, new_move), new_move_value,
                            location_to_string(internal_state, old_move), old_move_value);
                if (new_move != PASS_MOVE)
                    sgfCircle(node, I(new_move), J(new_move));
            }
        }
        else
            printf("%s - GNU Go plays the same move %s (%.2f)",
                        __func__, location_to_string(internal_state, new_move), new_move_value);

        sgfAddComment(node, buf);
        sgffile_add_debuginfo(internal_state, node, 0.0);
    }

    /* Finally, do play the move from the file. */
    QPoint point = GoTable::fromGnuGoPos(old_move);
    printf("%s - move=%d (%d:%d), color=%d\n", __func__, old_move, point.y(), point.x(), color);
    play_move(internal_state, old_move, color);
    sgftreeAddPlay(outTree, color, point.y(), point.x());
    lastMoveRow = point.y();
    lastMoveCol = point.x();

    (*playedMoves) += 1;
    (*crtColour) = color;
}

GoTable::GoTable()
{
    internal_state = new board_lib_state_struct;
    init_board_lib_state_struct(internal_state);
    gnuGoMutex = new QMutex;
    aiThread = new AIThread(gnuGoMutex);
    //connect(aiThread, SIGNAL(AIThreadPlaceStone(int,int)), this, SLOT(playMove(int,int)));
    //connect(aiThread, SIGNAL(AIQuitsGame(bool)), this, SLOT(finish(bool)));

    game.size = gameSettings.size;
    players[EMPTY] = PlayerType::None;
    changeGameSettings(gameSettings); //an idiotic move of copying gameSettings over gameSettings :D

    //global from board.h, keep track of it
    sgfTree = (SGFTree*)malloc(sizeof(SGFTree));
    sgfTree->lastnode = NULL;
    sgfTree->root = sgfNewNode();
    if (useGNUGO) {
        init_gnugo(internal_state, 50, 314);
        resetGnuGo(gameSettings.size);
    }

    //TODO - fix these joke data
    auxInfo.comment = "test save";
    auxInfo.freeGoVersion = "1000";
    auxInfo.gameDate = "2015-02-19T00:31";
    delete internal_state;
}


GoTable::~GoTable() {
    Logger::log(QString("%1 - Implement destructor!").arg(__func__));
    delete gnuGoMutex;
}

//This code is outside the constructor because this is executed after the signals of this object are connected
void GoTable::checkForResumeGame() {
    if (loadGame(crtGameSfgFName)) {
        state = GameState::Resumed;
    }
    else {
        crtPlayer = BLACK;
        state = GameState::Initial;
        resetGnuGo(gameSettings.size);
        populateStructFromGnuGo();
    }
}

GameState GoTable::getGameState() const {
    return state;
}

void GoTable::getPlayersState(int& crt, PlayerType& crtType, int& opponent, PlayerType& opponentType) const {
    crt = this->crtPlayer;
    if (crt == WHITE) {
        opponent = BLACK;
    }
    else {
        opponent = WHITE;
    }
    crtType = players[crtPlayer];
    opponentType = players[otherColour(crtPlayer)];
}

/**
 * @brief GoTable::setSecondPlayerToNetwork hack function to instruct that the second player is now of type network.
 */
void GoTable::setSecondPlayerToNetwork() {
    Logger::log(QString("%1").arg(__func__));
    if (gameSettings.white == PlayerType::LocalHuman) {
        gameSettings.black = PlayerType::Network;
    }
    else if (gameSettings.black == PlayerType::LocalHuman) {
        gameSettings.white = PlayerType::Network;
    }
    //emit pushGameSettings(gameSettings);
    //update();
}

void GoTable::changeProgramSettings() {
    //update();
}

SGameSettings* GoTable::getGameSettingsPointer() {
    return &gameSettings;
}

bool GoTable::saveGame(QJsonObject& json) {
    bool result = SaveFile::writeSave(json, sgfTree->root, &this->gameSettings, &auxInfo);
    return result;
}

bool GoTable::saveGame(QString fileName) {
    Logger::log(QString("%1, fileName=%2").arg(__func__).arg(fileName));
    bool result = SaveFile::writeSave(fileName, sgfTree->root, &this->gameSettings, &auxInfo);
    return result;
}

/**
 * @brief GoTable::saveGameForRemote serialise the game for playing with a remote (Network) player.
 * @param json
 * @return
 */
bool GoTable::saveGameForRemote(QJsonObject& json) {
    bool result = SaveFile::writeSaveForRemote(json, sgfTree->root, &this->gameSettings, &auxInfo);
    return result;
}

bool GoTable::loadGame(SGFNode* aux, SGameSettings auxSettings, SAuxGameInfo auxGameInfo) {
    sgfFreeNode(sgfTree->root);
    sgfTree->lastnode = NULL;
    sgfTree->root = sgfNewNode();

    changeGameSettings(auxSettings);
    //emit pushGameSettings(auxSettings);
    resetGnuGo(auxSettings.size);
    auxInfo = auxGameInfo;


    if (aux == nullptr) {
        Logger::log("aux == NULL", Logger::ERR);
        return false;
    }

    bool retVal = false;
    float replayScore = 0.0;
    float totalScore = 0.0;
    int playedMoves = 0;
    SGFNode* node = aux;
    while (node) {
      replay_node(node, EMPTY, &replayScore, &totalScore, &playedMoves, &crtPlayer, sgfTree);
      node = node->child;
    }

    Logger::log(QString("%1 - done replaying, replayScore=%2, totalScore=%3").arg(__func__).arg(replayScore).arg(totalScore));
    if (playedMoves > 0) {
        populateStructFromGnuGo();
        if (crtPlayer == BLACK)
            crtPlayer = WHITE;
        else
            crtPlayer = BLACK;
        retVal = true;
    }

    sgfFreeNode(aux);

    return retVal;
}

bool GoTable::loadGame(const QString fileName) {
    Logger::log(QString("%1, fileName=%2").arg(__func__).arg(fileName));
    QFile f(fileName);
    if (!f.exists() || !f.open(QIODevice::ReadOnly))
        return false;

    QByteArray data = f.readAll();

    SGFNode* aux = NULL;
    SGameSettings auxSettings;
    SAuxGameInfo auxGameInfo;

    bool success = SaveFile::loadSave(data, &aux, &auxSettings, &auxGameInfo);
    if (!success)
        return false;
    loadGame(aux, auxSettings, auxGameInfo);

    return success;
}

bool GoTable::loadGameFromRemote(const QJsonObject &json) {
    SGFNode* aux = NULL;
    SGameSettings auxSettings;
    SAuxGameInfo auxGameInfo;
    bool success = SaveFile::loadSave(json, &aux, &auxSettings, &auxGameInfo);
    if (!success) {
        Logger::log(QString("%1 - could not load remote save: %2").arg(__func__).arg(QJsonDocument(json).toJson().constData()), Logger::ERR);
        return false;
    }

    success = loadGame(aux, auxSettings, auxGameInfo);
    if (!success) {
        Logger::log(QString("%1 - loading failed. Investigate").arg(__func__));
    }

    if (success) {
        state = GameState::Resumed;
    }

    return success;
}

bool GoTable::loadGameAndStart(const QString fileName) {
    bool success = loadGame(fileName);
    if (success) {
        state = GameState::Resumed;
    }
    return success;
}

void GoTable::changeGameSettings(const SGameSettings& newSettings) {
    //TODO - check if there are other settings to be written here; should be the only place to change settings
    players[BLACK] = newSettings.black;
    players[WHITE] = newSettings.white;
    game.size = newSettings.size;
    if (gameSettings.size != newSettings.size) {
        printf("%s - settings.size=%d, newSettings.size=%d\n", __func__, gameSettings.size, newSettings.size);
        resetGnuGo(game.size);
    }
    if (newSettings.handicap.handicap != gameSettings.handicap.handicap) {
        resetGnuGo((game.size));
        insertDefaultHandicap(gameSettings.handicap.handicap);
    }
    internal_state->komi = gameSettings.handicap.komi;
    gameSettings = newSettings;
}

/**
 * @brief GoTable::playMove - try to play a move, all GUI conditions have been fullfilled, now check the logic ones.
 * Special case for the networked game: we play, and perform and undo in case the move is not accepted
 */
bool GoTable::playMove(const int row, const int col) {
    Logger::log(QString("%1: %2, %3. Player %4 of type %5").arg(__func__).arg(row).arg(col).arg(crtPlayer).arg(playerTypeMap.left.at(players[crtPlayer])));

    if (players[crtPlayer] == PlayerType::AI)
        computing = false;

    if (!moveIsLegal(row, col, crtPlayer)) {
        Logger::log(QString("Move not legal: %1 %2. Plyer %3 of type %4").arg(row).arg(col).arg(crtPlayer).arg(playerTypeMap.left.at(players[crtPlayer])), Logger::ERR);
        return false;
    }

    if (state == GameState::Stopped) {
        Logger::log(QString("Calling function %1 the game is stopped!").arg(__func__), Logger::ERR);
        return false;
    }

    if (row == FREEGO_PASS_MOVE) {
        passCount += 1;
        if (passCount >= PASS_COUNT_TO_FINISH) {
            Logger::log(QString("%1 - both players have passed consecutively, will end game.").arg(__func__));
            finish(false);
            return true;
        }
    }
    else {
        passCount = 0;
    }

    if (row == FREEGO_RESIGN_MOVE) {
        Logger::log(QString("%1 - finish by resignation of player %2.").arg(__func__).arg(crtPlayer));
        finish(true);
        return true;
    }

    bool retVal = false;
    if (useGNUGO) {
        play_move(internal_state, toGnuGoPos(row, col), crtPlayer);
        retVal = true;
        populateStructFromGnuGo();
    }
    else {
        retVal = GamePlaceStone(&game, row, col, crtPlayer);
    }

    if (retVal == false) {
        return retVal;
    }

    //Aici - with a remote player we need to spin and wait for confirmation later in the process


    //Here we're sure a move has been played
    if (state == GameState::Initial) {
        sgfFreeNode(sgfTree->root);
        sgfTree->lastnode = NULL;
        sgfTree->root = sgfNewNode();
    }

    sgftreeAddPlay(sgfTree, crtPlayer, row, col);
    SaveFile::writeSave(crtGameSfgFName, sgfTree->root, &this->gameSettings, &auxInfo);

    crtPlayer = otherColour(crtPlayer);

    if (state == GameState::Initial) {
        printf("%s - we just automatically started a new game!\n", __func__);
        state = GameState::Started;
        launchGame(false);
    }
    else {

        if (state == GameState::Resumed) {
            state = GameState::Started;
        }
        if (players[crtPlayer] == PlayerType::AI) {
            AIPlayNextMove();
        }
    }

    if (row == FREEGO_PASS_MOVE) {
        lastMoveRow = lastMoveCol = -2;
    }
    else {
        lastMoveRow = row;
        lastMoveCol = col;
    }

    if (estimateScore) {
        //hack to give GUI time to update
        //QTimer::singleShot(20, this, SLOT(computeScoreAndUpdate()));
    }

    Logger::log(QString("movePlayed: %1 %2").arg(row).arg(col));
    Logger::log(QString("Turn changed to: crtPlayer: %1, crtType: %2, otherType: %3").arg(crtPlayer).arg(playerTypeMap.left.at(players[crtPlayer])).arg(players[otherColour(crtPlayer)]));
    return retVal;
}

bool GoTable::passMove() {
    //should insert some logic for counting
    return true;
}

bool GoTable::undoMove() {
    //human-computer: undo twice, computer's and yours
    //human-human: undo once, players will cooperate somehow
    //network-x:no undo for now
    //can't undo on computer's turn, but you can undo after the match finishes
    int count = 0;
    if ((players[crtPlayer] == PlayerType::LocalHuman) /* || (state == GameState::Stopped)*/) {
        if (players[otherColour(crtPlayer)] == PlayerType::AI)
            count = 2;
        else if (players[otherColour(crtPlayer)] == PlayerType::LocalHuman)
            count = 1;
        else
            printf("%s - can't undo against network game\n", __func__);
    }

    int result = undo_move(internal_state, count);
    if (result == 1) {
        //success: go back in history too
        for(int i = 0; i < count; i++) {
            crtPlayer = otherColour(crtPlayer);
            sgftreeBack(sgfTree);
        }
        SaveFile::writeSave(crtGameSfgFName, sgfTree->root, &gameSettings, &auxInfo);
        populateStructFromGnuGo();
        return true;
    }
    return false;
}

//whenever waitForLock is false also sucess has to be non-null
//TODO - maybe move to AIThread to not block GUI
float GoTable::wrapper_gnugo_estimate_score(float *upper, float *lower, bool waitForLock, bool* success) {
    if (gnuGoMutex->tryLock() == false) {
        if (waitForLock == false) {
            *success = false;
            return -INFINITY;
        }
        gnuGoMutex->lock();
    }
    float score= gnugo_estimate_score(internal_state, upper, lower);
    gnuGoMutex->unlock();
    return score;
}

float GoTable::wrapper_aftermath_compute_score() {
    return aftermath_compute_score(internal_state, BLACK, NULL);
}

void GoTable::resetGnuGo(int newSize) {
    internal_state->board_size = newSize;
    if (gnuGoMutex->tryLock() == false) {
        printf("%s - avoided crash with mutex, but there's a logical error\n", __func__);
        gnuGoMutex->lock();
    }
    clear_board(internal_state);
    gnuGoMutex->unlock();
    //printfGnuGoStruct();
}

int GoTable::toGnuGoPos(int row, int col) {
    int pos = (row+1) * 20 + col + 1;
    if (row == FREEGO_PASS_MOVE)
        pos = 0;
    return pos;
}

//TODO - here we're just supposing that that table will stay the same size
QPoint GoTable::fromGnuGoPos(int pos) {
    int row = pos / 20 - 1;
    int col = pos - (row+1)*20 - 1;

    if (pos == 0) {
        col = FREEGO_PASS_MOVE;
        row = FREEGO_PASS_MOVE;
    }
    return QPoint(col, row);
}

void GoTable::printfGnuGoStruct() {
    for (int i = 0; i < 21; i++) {
        for (int j = 0; j < 20; j++)
            printf("%d", internal_state->board[i*20+j]);
        printf("\n");
    }
}

bool GoTable::moveIsLegal(int row, int col, int colour) {
    int pos = toGnuGoPos(row, col);
    if (row == FREEGO_PASS_MOVE)
        pos = PASS_MOVE;
    if (row == FREEGO_RESIGN_MOVE) {
        return true;
    }
    return (is_legal(internal_state, pos, colour));
}

int GoTable::populateStructFromGnuGo() {
    for (int i = 0; i < game.size; i++) {
        for(int j = 0; j < game.size; j++)
            game.state[i][j] = internal_state->board[toGnuGoPos(i, j)];
    }
    return 0;
}

/*
 * @param resetTable - the table won't be cleaned-up, this allow launching a game with a stone move.
 */
void GoTable::launchGame(bool resetTable) {
    sgfFreeNode(sgfTree->root);
    sgfTree->lastnode = NULL;
    sgfTree->root = sgfNewNode();

    game.size = gameSettings.size;
    players[BLACK] = gameSettings.black;
    players[WHITE] = gameSettings.white;
    if (resetTable) {
        if (gameSettings.handicap.handicap && gameSettings.handicap.handicapPlacementFree == false)
            crtPlayer = WHITE;
        else
            crtPlayer = BLACK;
        lastMoveRow = lastMoveCol = -1;
    }
    //emit crtPlayerChanged(crtPlayer, players[crtPlayer], players[otherColour(crtPlayer)]);
    //updateSizes();
    if (useGNUGO) {
        if (resetTable) {
            resetGnuGo(gameSettings.size);
            if (gameSettings.handicap.handicapPlacementFree == false)
                insertDefaultHandicap(gameSettings.handicap.handicap);
        }
        populateStructFromGnuGo();
    }

    //update();
    if (players[crtPlayer] == PlayerType::AI) {
        //QTimer::singleShot(2, this, SLOT(AIPlayNextMove()));
    }
}

float GoTable::finish(bool finishByResign) {
    float score = 0.0;

    if (gnuGoMutex->tryLock() == false) {
        Logger::log(QString("%1 - avoided crash with mutex, but there's a logical error").arg(__func__), Logger::ERR);
        gnuGoMutex->lock();
    }

    //TODO - actually here the mutex makes sense; because we can't kill the GnuGo thread and we still want the stop button to have effect
    //maybe show the user a dialog explaining what's hapening.

    crtPlayer = EMPTY;

    //File saving stuff
    QString oldSgfFName = crtGameSfgFName + ".old";
    QFile file(oldSgfFName);
    if (file.exists())
        file.remove();

    file.setFileName(crtGameSfgFName);
    file.rename(oldSgfFName);

    state = GameState::Stopped;

    gnuGoMutex->unlock();
    return score;
}

void GoTable::activateEstimatingScore(bool estimate) {
    estimateScore = estimate;
    if (estimate) {
        //QTimer::singleShot(20, this, SLOT(computeScoreAndUpdate()));
    }
}

int GoTable::insertDefaultHandicap(int newHandicap) {
    //http://en.wikipedia.org/wiki/Go_handicaps#Fixed_placement
    Logger::log(QString("%1 - newHandicap=%2").arg(__func__).arg(newHandicap));
    place_fixed_handicap(internal_state, newHandicap);
    populateStructFromGnuGo();
    //register all moves, since this is not done by GnuGo
    for(int row = 0; row < game.size; row++) {
        for(int col = 0; col < game.size; col++) {
            if (game.state[row][col] != 0) {
                sgftreeAddPlay(sgfTree, game.state[row][col], row, col);
            }
        }
    }

    //GnuGo may have decided the handicap is inappropriate for the table size
    if (newHandicap != internal_state->handicap) {
        gameSettings.handicap.handicap = internal_state->handicap;
    }
    return internal_state->handicap;
}

bool GoTable::AIPlayNextMove() {
    int AIStrength = gameSettings.blackAIStrength;
    if (crtPlayer == WHITE) {
        AIStrength = gameSettings.whiteAIStrength;
    }
    aiThread->run_genmove(crtPlayer, AIStrength);

    updateLogic();

    return false;
}

//When we're waiting for a result coming from a different thread we need to check the result from the other thread
void GoTable::updateLogic() {
    //Logger::log(QString("%1").arg(__func__), Logger::DBG);

    if (aiThread->mutex->tryLock()) {
            Logger::log(QString("%1 - the AIThread is done!").arg(__func__), Logger::DBG);
        }
    else {
        Logger::log(QString("%1 - the AIThread is still computing.").arg(__func__), Logger::DBG);
        std::function<void(void)> f = std::bind(&GoTable::updateLogic, this);
        QTimer::singleShot(1, f);
    }
}

AIThread::AIThread(QMutex *mutex) : mutex(mutex) {

}

bool AIThread::run_genmove(int color, int AIStrength) {
    mutex->lock();
    printf("%s - color=%d\n", __func__, color);
    if(running)
        return false;

    running = true;
    p.operation = OpType::do_genmove;
    p.color = color;
    p.strength = AIStrength;
    p.value = 0;
    p.resign = 0;
    p.result = 0;
    start();
    return true;
}

bool AIThread::run_gnugo_estimate_score() {
    mutex->lock();
    if(running)
        return false;
    running = true;
    p.operation = OpType::gnugo_estimate_score;
    start();
    return true;
}

void AIThread::run_value_moves(board_lib_state_struct* internal_state, int colour) {
//    if (mutex->tryLock() == false) {
//        printf("%s - avoided crash with mutex, but there's a logical error\n", __func__);
//        mutex->lock();
//    }

    //value_moves(internal_state, colour, 0.0, 0.0, 1);
    //run genmove to fill in best_move_values
    this->internal_state = internal_state;
    set_level(2);
    int val = genmove(internal_state, colour, NULL, NULL);
    Q_UNUSED(val);
    mutex->unlock();;
}

void AIThread::run() {
    printf("%s - running on thread %p\n", __func__, QThread::currentThreadId());

//    if (mutex->tryLock() == false) {
//        printf("%s - avoided crash with mutex, but there's a logical error\n", __func__);
//        mutex->lock();
//    }
    set_level(p.strength);
    p.result = genmove(internal_state, p.color, &p.move_value, &p.resign);
    mutex->unlock();

    int move = p.result;
    if (p.resign) {
        Logger::log(QString("%1 - AI has decided to resign, will compute finals scores.").arg(__func__));
        float score = gnugo_estimate_score(internal_state, NULL, NULL);
        if (score > 0) {
            printf("%s - estimates: white winning by %f\n", __func__, score);
        }
        else {
            printf("%s - estimates: black winning by %f\n", __func__, -score);
        }
        //emit AIQuitsGame(true);
    }
    else {
        QPoint point = GoTable::fromGnuGoPos(move);
        printf("%s - AI has finished, move of value=%f, at %d, %d\n", __func__, p.move_value, point.y(), point.x());
        //emit AIThreadPlaceStone(point.y(), point.x());
    }

    running = false;
}
